install.packages(shiny)
install.packages("shiny")
ls
install.packages("data.frame")
install.packages("data.tables")
library(shiny)
runExample("01_hello")
runExample("01_hello")
ui <-
q
test <- c(1:3)
install.packages("profvis")
library(profvis)
shiny::runApp('code/sialab/covid_vis')
runApp('code/sialab/covid_vis')
profvis({runExample(example = "06_tabsets", display.mode = "normal")})
pop <- fread("our_data/US/census_pop_2019.csv")
library(data.table)
pop <- fread("our_data/US/census_pop_2019.csv")
#setwd("/home/ubuntu/covid_vis")
setwd("/home/lofatdairy/code/sialab/covid_vis")
pop <- fread("our_data/US/census_pop_2019.csv")
pop
pop$POPESTIMATE2019
pop$POPESTIMATE2019 %>% max()
pop[, Location := paste0(CTYNAME, ", ", STNAME)]
pop[, Location := paste0(CTYNAME, ", ", STNAME)]
pop
split(pop$CTYNAME, " ")
split(pop$CTYNAME, " County")
split(pop$CTYNAME[1], " County")
split(pop$CTYNAME[2], " County")
split(pop$CTYNAME[2], " ")
test <- pop$CTYNAME
test
test <- pop$CTYNAME[1]
test <- pop$CTYNAME[2]
test
library(dplyr)
test %>% split(" ")
split(as.character(pop$CTYNAME[2]), " ")
strsplit(pop$CTYNAME[2], " County")
strsplit(pop$CTYNAME, " County")
strsplit(pop$CTYNAME, " County") %>% unlist
pop[, Location := paste0(unlist(strsplit(CTYNAME, " County")), ", ", STNAME)]
pop
strsplit(pop$CTYNAME, " County") %>% unlist()
test <- strsplit(pop$CTYNAME, " County") %>% unlist()
test[1835]
pop$CTYNAME
pop$CTYNAME[1835]
pop[1835]
pop$CTYNAME[1835] <- "Dona Ana County"
pop <- fread("our_data/US/census_pop_2019.csv")
pop$CTYNAME[1835] <- "Dona Ana County"
pop[, Location := paste0(unlist(strsplit(CTYNAME, " County")), ", ", STNAME)]
poop
pop
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
# Reads in the geojson describing the county boundaries. This gives leaflet a set of points for each county that
# describes the county's border. you can think of counties as actually a dictionary with 7 key-value pairs, the
# value of each field each being a vector. the most important fields for our use are NAME and STATENAME,
# which are the county's name and the state's name, respectively.
# A side note: the reason that counties is declared outside the server function is that this allows for its
# value to be cached, so we don't have to read the big ass json file each time the shiny app is started.
counties <- readOGR("our_data/US/counties.json")
library(rgdal)
# Reads in the geojson describing the county boundaries. This gives leaflet a set of points for each county that
# describes the county's border. you can think of counties as actually a dictionary with 7 key-value pairs, the
# value of each field each being a vector. the most important fields for our use are NAME and STATENAME,
# which are the county's name and the state's name, respectively.
# A side note: the reason that counties is declared outside the server function is that this allows for its
# value to be cached, so we don't have to read the big ass json file each time the shiny app is started.
counties <- readOGR("our_data/US/counties.json")
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
# aggregated is basically taking all the observations in obs, and grouping them by state and county (some county
# names are the same in different states, so we use both). For example, if there are 100 observations in LA, California,
# and 50 are positive, then the aggregated table will look like this:
# County, State, Tests, Positive, Location
# Los Angeles, California, 100, 50, "Los Angeles, California"
# Note that Location is basically the combination of county and state name (again because county name is not unique)
# to generate a unique string, and then location is made the key for the data.table, basically turning it into a hash
# map. This is important later, because we have to map number of tests and number of cases to each county for the
# counties dictionary, and this lets us accomplish that quickly and concisely
aggregated <- obs[, .(Tests = length(Positive), Positive = sum(Positive)), by = .(County, State)]
aggregated[, Location := paste0(County, ", ", State)]
setkey(aggregated, Location)
# obs is a data.table object (just like pandas data frames if you're familiar with that), with each
# observation being a single test taken. each observation is the county, state, lat, long, outcome (positive or negative)
# update time, race, hispanic, and age of the user/test.
obs <- fread("our_data/test/test.csv")
pop <- fread("our_data/US/census_pop_2019.csv")
pop$CTYNAME[1835] <- "Dona Ana County"
pop[, Location := paste0(unlist(strsplit(CTYNAME, " County")), ", ", STNAME)]
# aggregated is basically taking all the observations in obs, and grouping them by state and county (some county
# names are the same in different states, so we use both). For example, if there are 100 observations in LA, California,
# and 50 are positive, then the aggregated table will look like this:
# County, State, Tests, Positive, Location
# Los Angeles, California, 100, 50, "Los Angeles, California"
# Note that Location is basically the combination of county and state name (again because county name is not unique)
# to generate a unique string, and then location is made the key for the data.table, basically turning it into a hash
# map. This is important later, because we have to map number of tests and number of cases to each county for the
# counties dictionary, and this lets us accomplish that quickly and concisely
aggregated <- obs[, .(Tests = length(Positive), Positive = sum(Positive)), by = .(County, State)]
aggregated[, Location := paste0(County, ", ", State)]
setkey(aggregated, Location)
# This line is somewhat busy, and there's a few things going on. The general idea is this: we need a vector containing
# the number of positive cases in each county, and the counts NEED to be in the same order as the order of the county
# names in counties$NAMES, otherwise the counts won't be correct. The way this is done is simply taking the counties$NAME
# and counties$STATENAME vector, and combining them item by item to form "NAME, STATENAME" strings, which match the format
# of our keys in aggregated. Then we can go along this new vector, and treat it as a key vector for our aggregated hash table,
# which ends up returning a data.table that contains only the rows we queried for, in the same order we queried them in. We then
# only care about the "Positive" field, because we're getting number of cases, so we extract that column as a vector at the end.
# The reason that there's a somewhat convoluted in_else function in there, is because NY state is aggrevating and reports all
# cases in all 5 boroughs as "NYC", so queries like "Bronx, New York", don't have an entry in aggregated, and would be NA. So
# we just treat all these locations as "New York City, New York", and return the number of cases there.
counties$cases <- aggregated[if_else(counties$STATENAME == "New York" & counties$NAME %in% c("Bronx", "New York", "Kings", "Queens", "Richmond"), "New York City, New York", paste0(counties$NAME, ", ", counties$STATENAME)), Positive]
# This line basically takes all NA values in the counties$cases vector and converts them to 0. Counties will no cases are not
# listed in aggregated
counties$cases[is.na(counties$cases)] <- 0
<<<<<<< HEAD
counties$cases
runApp()
profvis(runApp("~/code/sialab/covid_vis/app.r"))
counties$NAME[counties$LSAD == "Muno"]
countiesTest <- geojsonR::shiny_from_JSON("./our_data/US/counties.json")
runApp()
countiesTest
countiesTest <- geojsonR::FROM_GeoJson("./our_data/US/counties.json", Flatten_Coords = T)
countiesTest$features[[1]]
countiesTest$features[[2]]
countiesTest$features[[3]]
countiesTest$type
countiesTest <- geojsonR::FROM_GeoJson("./our_data/US/counties.json", Flatten_Coords = F)
countiesTest$features[[3]]
countiesTest <- geojsonio::geojson_read("./our_data/US/counties.json", what = "sp")
countiesTest
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addGeoJSON()
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
#label = ~paste0(NAME),
group = "Tested"
) %>%
# addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = ~ifelse(cases == 0, .5, .7),
#             color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
#             label = ~paste0(NAME, ", ", STATENAME, ": ", cases),
#             group = "Positive"
#           ) %>%
addLayersControl(
baseGroups = c("Positive", "Tested"),
options = layersControlOptions(collapsed = FALSE)
)
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
#label = ~paste0(NAME),
group = "Tested"
) %>%
# addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = ~ifelse(cases == 0, .5, .7),
#             color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
#             label = ~paste0(NAME, ", ", STATENAME, ": ", cases),
#             group = "Positive"
#           ) %>%
addLayersControl(
baseGroups = c("Positive", "Tested"),
options = layersControlOptions(collapsed = FALSE)
)
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
color = ~"#00FF00",
label = ~paste0(NAME),
group = "Tested"
) %>%
# addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = ~ifelse(cases == 0, .5, .7),
#             color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
#             label = ~paste0(NAME, ", ", STATENAME, ": ", cases),
#             group = "Positive"
#           ) %>%
addLayersControl(
baseGroups = c("Positive", "Tested"),
options = layersControlOptions(collapsed = FALSE)
)
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
color = ~pal(0),
label = ~paste0(NAME),
group = "Tested"
) %>%
# addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = ~ifelse(cases == 0, .5, .7),
#             color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
#             label = ~paste0(NAME, ", ", STATENAME, ": ", cases),
#             group = "Positive"
#           ) %>%
addLayersControl(
baseGroups = c("Positive", "Tested"),
options = layersControlOptions(collapsed = FALSE)
)
pal <- colorBin(colorRamp(c("#FFDD00","#FF0000")), domain = NULL, bins = 15)
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
color = ~pal(0),
label = ~paste0(NAME),
group = "Tested"
) %>%
# addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = ~ifelse(cases == 0, .5, .7),
#             color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
#             label = ~paste0(NAME, ", ", STATENAME, ": ", cases),
#             group = "Positive"
#           ) %>%
addLayersControl(
baseGroups = c("Positive", "Tested"),
options = layersControlOptions(collapsed = FALSE)
)
leaflet(countiesTest) %>%
addTiles() %>%
addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
label = ~paste0(NAME),
group = "Tested"
) %>%
addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = ~ifelse(cases == 0, .5, .7),
color = ~ifelse(cases == 0, "#00FF00", pal(as.numeric(log10(cases)))),
label = ~paste0(NAME, ", ", STATENAME, ": ", cases),
group = "Positive"
) %>%
addLayersControl(
baseGroups = c("Positive", "Tested"),
options = layersControlOptions(collapsed = FALSE)
)
runApp()
runApp()
shinytest
install.packages(testthat)
installed.packages(())
installed.packages()
runApp()
install.packages(shiny)
install.packages("shiny")
ls
install.packages("data.frame")
version
install.packages("data.tables")
library(name_UI <- function(id) {
ns <- NS(id)
tagList(
)
}
name <- function(input, output, session) {
})
shiny::runApp('code/sialab/covid_vis')
runApp()
ls
clear
runApp()
install.packages("shiny")
install.packages("shiny")
library("shiny")
shinytest
install.packages(testthat)
install.packages("data.table")
install.packages("dplyr")
install.packages("leaflet")
install.packages("leaflet.extras")
install.packages("rgdal")
install.packages("DT")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("shinydashboard")
runApp()
runApp()
runApp()
runApp('ui.R')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
head(global_header)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(shiny)
library(leaflet)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
=======
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$tests <- aggregated[if_else(counties$STATENAME == "New York" & counties$NAME %in% c("Bronx", "New York", "Kings", "Queens", "Richmond"), "New York City, New York", paste0(counties$NAME, ", ", counties$STATENAME)), Tests]
counties$tests[is.na(counties$tests)] <- 0
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
setkey(pop, Location)
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
pop[, Location := paste0(unlist(strsplit(CTYNAME, " County")), ", ", STNAME)]
setkey(pop, Location)
nrow(pop)
length(counties$COUNTY)
counties[counties$COUNTY == ""] <- NULL
length(counties$COUNTY)
counties[counties$COUNTY == ""]
counties[[counties$COUNTY == ""]] <- NULL
counties[[counties$COUNTY == ""]]
[counties$COUNTY == ""]
counties$COUNTY == ""
counties$COUNTY == "" %>% sum
counties$COUNTY == "" %>% sum()
counties$COUNTY == "" %>% sum(.)
counties$COUNTY == ""
sum(counties$COUNTY == "")
counties$NAME == ""
sum(counties$NAME == "")
counties$NAME
# Reads in the geojson describing the county boundaries. This gives leaflet a set of points for each county that
# describes the county's border. you can think of counties as actually a dictionary with 7 key-value pairs, the
# value of each field each being a vector. the most important fields for our use are NAME and STATENAME,
# which are the county's name and the state's name, respectively.
# A side note: the reason that counties is declared outside the server function is that this allows for its
# value to be cached, so we don't have to read the big ass json file each time the shiny app is started.
counties <- readOGR("our_data/US/counties.json")
counties$COUNTY
counties$NAME
counties$NAME == ""
sum(counties$NAME == "")
sum(counties$NAME == " ")
sum(counties$NAME)
counties$NAME
counties$NAME %>% as.character()
as.character(countries$NAME)
as.character(counties$NAME)
as.character(counties$NAME) == ""
as.character(counties$NAME) == "" %>% sum()
sum(as.character(counties$NAME) == "")
counties$NAME levels
counties$NAME %>% levels()
counties$STATENAME == "Alabama"
sum(counties$STATENAME == "Alabama")
sum(counties$STATENAME == "Alaska")
sum(counties$STATENAME == "Arison")
sum(counties$STATENAME == "Arizona")
sum(counties$STATENAME == "Arkansas")
sum(counties$STATENAME == "California")
sum(counties$STATENAME == "Colorado")
sum(counties$STATENAME == "Connecticut")
sum(counties$STATENAME == "")
sum(counties$STATENAME == "Delaware")
sum(counties$STATENAME == "District of Columbia")
sum(counties$STATENAME == "Florida")
sum(counties$STATENAME == "Georgia")
sum(counties$STATENAME == "Hawaii")
sum(counties$STATENAME == "Idaho")
sum(counties$STATENAME == "Iowa")
sum(counties$STATENAME == "Kansas")
sum(counties$STATENAME == "Kentucky")
sum(counties$STATENAME == "Louisiana")
sum(counties$STATENAME == "Maine")
sum(counties$STATENAME == "Maryland")
sum(counties$STATENAME == "Massachusetts")
sum(counties$STATENAME == "Michigan")
sum(counties$STATENAME == "Minnesota")
sum(counties$STATENAME == "Mississippi")
sum(counties$STATENAME == "Missouri")
sum(counties$STATENAME == "Montana")
sum(counties$STATENAME == "Nebraska")
sum(counties$STATENAME == "Nevada")
sum(counties$STATENAME == "New Hampshire")
sum(counties$STATENAME == "New Jersey")
sum(counties$STATENAME == "New Mexico")
sum(counties$STATENAME == "New York")
sum(counties$STATENAME == "North Carolina")
sum(counties$STATENAME == "North Dakota")
sum(counties$STATENAME == "Ohio")
sum(counties$STATENAME == "Oklahoma")
sum(counties$STATENAME == "Oregon")
sum(counties$STATENAME == "Pennsylvania")
sum(counties$STATENAME == "Rhode Island")
sum(counties$STATENAME == "South Carolina")
sum(counties$STATENAME == "South Dakota")
sum(counties$STATENAME == "Tennessee")
sum(counties$STATENAME == "Texas")
sum(counties$STATENAME == "Utah")
sum(counties$STATENAME == "Vermont")
sum(counties$STATENAME == "Virginia")
sum(counties$STATENAME == "Washington")
sum(counties$STATENAME == "West Virginia")
sum(counties$STATENAME == "Wisconsin")
sum(counties$STATENAME == "Wyoming")
sum(counties$STATENAME %in% state.names)
state\
state.name
sum(counties$STATENAME %in% state.name)
counties$NAME[counties$STATENAME == "Virginia"]
counties$NAME[counties$STATENAME == "Virginia"] %>% as.character() %>% sort.default()
counties$NAME[counties$STATENAME %in% state.name]
counties$NAME[!counties$STATENAME %in% state.name]
counties$STATE[!counties$STATENAME %in% state.name]
counties$STATENAME[!counties$STATENAME %in% state.name]
sum(counties$STATENAME == "Puerto Rico"
sum(counties$STATENAME == "Puerto Rico")
sum(counties$STATENAME == "Puerto Rico")
length(counties$STATENAME) - sum(counties$STATENAME == "Puerto Rico")
nrow(pop)
counties[counties$STATENAME == "Puerto Rico"]
counties[[counties$STATENAME == "Puerto Rico"]]
counties$STATENAME == "Puerto Rico"
counties[[counties$STATENAME == "Puerto Rico"]]
counties[[counties$STATENAME != "Puerto Rico"]]
counties[counties$STATENAME != "Puerto Rico"]
for i in length(counties)
for i in length(counties){}
for (i in length(counties)) {}
for (i in length(counties)) {if counties$STATENAME == "Puerto Rico" {counties[[i]] <- NULL}}
for (i in length(counties)) {if (counties$STATENAME == "Puerto Rico") {counties[[i]] <- NULL}}
for (i in length(counties)) {
if (counties$STATENAME == "Puerto Rico") {
counties[[i]] <- NULL
}
}
for (i in length(counties)) {
if (counties[[i]]$STATENAME == "Puerto Rico") {
counties[[i]] <- NULL
}
}
# Reads in the geojson describing the county boundaries. This gives leaflet a set of points for each county that
# describes the county's border. you can think of counties as actually a dictionary with 7 key-value pairs, the
# value of each field each being a vector. the most important fields for our use are NAME and STATENAME,
# which are the county's name and the state's name, respectively.
# A side note: the reason that counties is declared outside the server function is that this allows for its
# value to be cached, so we don't have to read the big ass json file each time the shiny app is started.
counties <- readOGR("our_data/US/counties.json")
for (i in length(counties)) {
if (counties[[i]]$STATENAME == "Puerto Rico") {
counties[[i]] <- NULL
}
}
# Reads in the geojson describing the county boundaries. This gives leaflet a set of points for each county that
# describes the county's border. you can think of counties as actually a dictionary with 7 key-value pairs, the
# value of each field each being a vector. the most important fields for our use are NAME and STATENAME,
# which are the county's name and the state's name, respectively.
# A side note: the reason that counties is declared outside the server function is that this allows for its
# value to be cached, so we don't have to read the big ass json file each time the shiny app is started.
counties <- readOGR("our_data/US/counties.json")
which(counties$STATENAME == "Puerto Rico")
temp <- which(counties$STATENAME == "Puerto Rico")
counties[[temp]] <- NULL
counties[[temp]]
# Reads in the geojson describing the county boundaries. This gives leaflet a set of points for each county that
# describes the county's border. you can think of counties as actually a dictionary with 7 key-value pairs, the
# value of each field each being a vector. the most important fields for our use are NAME and STATENAME,
# which are the county's name and the state's name, respectively.
# A side note: the reason that counties is declared outside the server function is that this allows for its
# value to be cached, so we don't have to read the big ass json file each time the shiny app is started.
counties <- readOGR("our_data/US/counties.json")
counties[[1]]
counties[[2]]
counties[3]
counties[4]
counties[5]
counties[6]
counties[[1]]
counties[[5]]
counties[-temp]
counties[counties$STATENAME != "Puerto Rico"]
counties[-temp]
counties <- counties[-temp]
sum(counties$STATENAME == "Puerto Rico")
counties[1][[1]]
counties[1][[2]]
counties[1]
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- if_else(counties$STATENAME != "Puerto Rico", pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019], 1)
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- ifelse(counties$STATENAME != "Puerto Rico", pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019], 1)
counties$pop
# Basically the same thing as the previous line except now we match counties to the number of tests
counties$pop <- pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
pop %>% nrow()
counties$pop %>% length()
pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019]
pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019] %>% nrow()
pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019] %>% length()
counties$NAME %>% length()
pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019] %>% is.na()
pop[paste0(counties$NAME, ", ", counties$STATENAME), POPESTIMATE2019] %>% is.na() %>% sum
pop[paste0(counties$NAME, ", ", counties$STATENAME)]
pop[paste0(counties$NAME, ", ", counties$STATENAME)] %>% nrow()
pop[paste0(counties$NAME, ", ", counties$STATENAME)]["Location"]
pop[paste0(counties$NAME, ", ", counties$STATENAME)][,"Location"]
fwrite(pop[paste0(counties$NAME, ", ", counties$STATENAME)][,"Location"], file = "./temp.csv")
paste0(counties$NAME, ", ", counties$STATENAME)
paste0(counties$NAME, ", ", counties$STATENAME) %>% length()
setdiff(paste0(counties$NAME, ", ", counties$STATENAME), pop[paste0(counties$NAME, ", ", counties$STATENAME), Location])
pop[paste0(counties$NAME, ", ", counties$STATENAME), Location]
pop[paste0(counties$NAME, ", ", counties$STATENAME), Location] %>% duplicated()
pop
pop[paste0(counties$NAME, ", ", counties$STATENAME), Location] %>% duplicated()
pop[CTYNAME == STNAME]
pop[paste0(counties$NAME, ", ", counties$STATENAME), Location] %>% duplicated() %>% sum()
pop[CTYNAME == "Arkansas"]
pop[CTYNAME == "Arkansas County"]
pop[function(x) {!grepl("County", x)}]
pop[!grepl("County", pop$CTYNAME)]
pop[!grepl("County", pop$CTYNAME), CTYNAME]
pop[!grepl("County|city|City|Parish", pop$CTYNAME)]
pop[!grepl("County|city|City|Parish", pop$CTYNAME), CTYNAME]
pop[!grepl("County|city|City|Parish|Borough", pop$CTYNAME), CTYNAME]
pop[!grepl("County|city|City|Parish|Borough|Area", pop$CTYNAME), CTYNAME]
pop[!grepl("County|city|City|Parish|Borough|Area|Municitpality", pop$CTYNAME), CTYNAME]
pop[!grepl("County|city|City|Parish|Borough|Area|Municipality", pop$CTYNAME), CTYNAME]
pop[CTYNAME == "District of Columbia"]
pop[STNAME == "Alabama"]
pop[CTYNAME == "District of Columbia"]
pop[CTYNAME == "District of Columbia" & COUNTY == 1] <- NULL
pop[!(CTYNAME == "District of Columbia" & COUNTY == 1)]
pop <- fread("our_data/US/census_pop_2019.csv")
pop$CTYNAME[1835] <- "Dona Ana County"
pop[!(CTYNAME == "District of Columbia" & COUNTY == 1)]
pop <- pop[!(CTYNAME == "District of Columbia" & COUNTY == 1)]
>>>>>>> 0d2b84a6b835c90ba563b5b8a611e98bbea991f5
